
<!DOCTYPE html><html><head><title>R: colins_datf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>colins_datf</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>colins_datf</h2>

<h3>Description</h3>

<p>Allow to insert vectors into a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colins_datf(inpt_datf, target_col = list(), target_pos = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inpt_datf">inpt_datf</code></td>
<td>
<p>is the dataframe where vectors will be inserted</p>
</td></tr>
<tr><td><code id="target_col">target_col</code></td>
<td>
<p>is a list containing all the vectors to be inserted</p>
</td></tr>
<tr><td><code id="target_pos">target_pos</code></td>
<td>
<p>is a list containing the vectors made of the columns names or numbers where the associated vectors from target_col will be inserted after</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
datf1 &lt;- data.frame("frst_col"=c(1:5), "scd_col"=c(5:1))

print(colins_datf(inpt_datf=datf1, target_col=list(c("oui", "oui", "oui", "non", "non"), 
             c("u", "z", "z", "z", "u")), 
                target_pos=list(c("frst_col", "scd_col"), c("scd_col"))))

#  frst_col cur_col scd_col cur_col.1 cur_col
#1        1     oui       5       oui       u
#2        2     oui       4       oui       z
#3        3     oui       3       oui       z
#4        4     non       2       non       z
#5        5     non       1       non       u

print(colins_datf(inpt_datf=datf1, target_col=list(c("oui", "oui", "oui", "non", "non"), 
             c("u", "z", "z", "z", "u")), 
                target_pos=list(c(1, 2), c("frst_col"))))

#  frst_col cur_col scd_col cur_col cur_col
#1        1     oui       5       u     oui
#2        2     oui       4       z     oui
#3        3     oui       3       z     oui
#4        4     non       2       z     non
#5        5     non       1       u     non

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: cut_v</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>cut_v</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>cut_v</h2>

<h3>Description</h3>

<p>Allow to convert a vector to a dataframe according to a separator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_v(inpt_v, sep_ = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inpt_v">inpt_v</code></td>
<td>
<p>is the input vector</p>
</td></tr>
<tr><td><code id="sep_">sep_</code></td>
<td>
<p>is the separator of the elements in inpt_v, defaults to &quot;&quot;</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
print(cut_v(inpt_v=c("oui", "non", "oui", "non")))

#    X.o. X.u. X.i.
#oui "o"  "u"  "i" 
#non "n"  "o"  "n" 
#oui "o"  "u"  "i" 
#non "n"  "o"  "n" 

print(cut_v(inpt_v=c("ou-i", "n-on", "ou-i", "n-on"), sep_="-"))

#     X.ou. X.i.
#ou-i "ou"  "i" 
#n-on "n"   "on"
#ou-i "ou"  "i" 
#n-on "n"   "on"

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: diff_datf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>diff_datf</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>diff_datf</h2>

<h3>Description</h3>

<p>Returns a vector with the coordinates of the cell that are not equal between 2 dataframes (row, column).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_datf(datf1, datf2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datf1">datf1</code></td>
<td>
<p>is an an input dataframe</p>
</td></tr>
<tr><td><code id="datf2">datf2</code></td>
<td>
<p>is an an input dataframe</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
datf1 &lt;- data.frame(c(1:6), c("oui", "oui", "oui", "oui", "oui", "oui"), c(6:1))

datf2 &lt;- data.frame(c(1:7), c("oui", "oui", "oui", "oui", "non", "oui", "zz"))

print(diff_datf(datf1=datf1, datf2=datf2)) 

#[1] 5 1 5 2

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: groupr_datf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>groupr_datf</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>groupr_datf</h2>

<h3>Description</h3>

<p>Allow to create groups from a dataframe. Indeed, you can create conditions that lead to a flag value for each cell of the input dataframeaccording to the cell value. This function is based on see_datf and nestr_datf2 functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupr_datf(
  inpt_datf,
  condition_lst,
  val_lst,
  conjunction_lst,
  rtn_val_pos = c()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inpt_datf">inpt_datf</code></td>
<td>
<p>is the input dataframe</p>
</td></tr>
<tr><td><code id="condition_lst">condition_lst</code></td>
<td>
<p>is a list containing all the condition as a vector for each group</p>
</td></tr>
<tr><td><code id="val_lst">val_lst</code></td>
<td>
<p>is a list containing all the values associated with condition_lst as a vector for each group</p>
</td></tr>
<tr><td><code id="conjunction_lst">conjunction_lst</code></td>
<td>
<p>is a list containing all the conjunctions associated with condition_lst and val_lst as a vector for each group</p>
</td></tr>
<tr><td><code id="rtn_val_pos">rtn_val_pos</code></td>
<td>
<p>is a vector containing all the group flag value like this ex: c(&quot;flag1&quot;, &quot;flag2&quot;, &quot;flag3&quot;)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>interactive()

datf1 &lt;- data.frame(c(1, 2, 1), c(45, 22, 88), c(44, 88, 33))
                                                                      
val_lst &lt;- list(list(c(1), c(1)), list(c(2)), list(c(44, 88)))

condition_lst &lt;- list(c("&gt;", "&lt;"), c("%%"), c("==", "=="))

conjunction_lst &lt;- list(c("|"), c(), c("|"))

rtn_val_pos &lt;- c("+", "++", "+++")

print(groupr_datf(inpt_datf=datf1, val_lst=val_lst, condition_lst=condition_lst, 
conjunction_lst=conjunction_lst, rtn_val_pos=rtn_val_pos))

#    X1  X2  X3
#1 &lt;NA&gt;   + +++
#2   ++  ++ +++
#3 &lt;NA&gt; +++   +

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: id_keepr_datf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>id_keepr</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>id_keepr_datf</h2>

<h3>Description</h3>

<p>Allow to get the original indexes after multiple equality comparaison according to the original number of row
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id_keepr(inpt_datf, col_v = c(), el_v = c(), rstr_l = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inpt_datf">inpt_datf</code></td>
<td>
<p>is the input dataframe</p>
</td></tr>
<tr><td><code id="col_v">col_v</code></td>
<td>
<p>is the vector containing the column numbers or names to be compared to their respective elements in &quot;el_v&quot;</p>
</td></tr>
<tr><td><code id="el_v">el_v</code></td>
<td>
<p>is a vector containing the elements that may be contained in their respective column described in &quot;col_v&quot;</p>
</td></tr>
<tr><td><code id="rstr_l">rstr_l</code></td>
<td>
<p>is a list containing the vector composed of the indexes of the elements chosen for each comparison. If the length of the list is inferior to the lenght of comparisons, so the last vector of rstr_l will be the same as the last one to fill make rstr_l equal in term of length to col_v and el_v</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
datf1 &lt;- data.frame(c("oui", "oui", "oui", "non", "oui"), 
     c("opui", "op", "op", "zez", "zez"), c(5:1), c(1:5))

print(id_keepr(inpt_datf=datf1, col_v=c(1, 2), el_v=c("oui", "op")))

#[1] 2 3

print(id_keepr(inpt_datf=datf1, col_v=c(1, 2), el_v=c("oui", "op"), 
     rstr_l=list(c(1:5), c(3, 2, 2, 2, 3))))

#[1] 2 3

print(id_keepr(inpt_datf=datf1, col_v=c(1, 2), el_v=c("oui", "op"), 
     rstr_l=list(c(1:5), c(3))))

#[1] 3

print(id_keepr(inpt_datf=datf1, col_v=c(1, 2), el_v=c("oui", "op"), rstr_l=list(c(1:5))))

#[1] 2 3

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: edm1 insert_datf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>insert_datf</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>edm1
insert_datf</h2>

<h3>Description</h3>

<p>Allow to insert dataframe into another dataframe according to coordinates (row, column) from the dataframe that will be inserted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert_datf(datf_in, datf_ins, ins_loc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datf_in">datf_in</code></td>
<td>
<p>is the dataframe that will be inserted</p>
</td></tr>
<tr><td><code id="datf_ins">datf_ins</code></td>
<td>
<p>is the dataset to be inserted</p>
</td></tr>
<tr><td><code id="ins_loc">ins_loc</code></td>
<td>
<p>is a vector containg two parameters (row, column) of the begining for the insertion</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
datf1 &lt;- data.frame(c(1, 4), c(5, 3))

datf2 &lt;- data.frame(c(1, 3, 5, 6), c(1:4), c(5, 4, 5, "ereer"))

print(insert_datf(datf_in=datf2, datf_ins=datf1, ins_loc=c(4, 2)))

#   c.1..3..5..6. c.1.4. c.5..4..5...ereer..
# 1             1      1                   5
# 2             3      2                   4
# 3             5      3                   5
# 4             6      1                   5

print(insert_datf(datf_in=datf2, datf_ins=datf1, ins_loc=c(3, 2)))

#   c.1..3..5..6. c.1.4. c.5..4..5...ereer..
# 1             1      1                   5
# 2             3      2                   4
# 3             5      1                   5
# 4             6      4                   3

print(insert_datf(datf_in=datf2, datf_ins=datf1, ins_loc=c(2, 2)))

#   c.1..3..5..6. c.1.4. c.5..4..5...ereer..
# 1             1      1                   5
# 2             3      1                   5
# 3             5      4                   3
# 4             6      4               ereer

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: intersect_mod</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>intersect_mod</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>intersect_mod</h2>

<h3>Description</h3>

<p>Returns the mods that have elements in common
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersect_mod(datf, inter_col, mod_col, n_min, descendly_ordered = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datf">datf</code></td>
<td>
<p>is the input dataframe</p>
</td></tr>
<tr><td><code id="inter_col">inter_col</code></td>
<td>
<p>is the column name or the column number of the values that may be commun betwee the different mods</p>
</td></tr>
<tr><td><code id="mod_col">mod_col</code></td>
<td>
<p>is the column name or the column number of the mods in the dataframe</p>
</td></tr>
<tr><td><code id="n_min">n_min</code></td>
<td>
<p>is the minimum elements in common a mod should have to be taken in count</p>
</td></tr>
<tr><td><code id="ordered_descendly">ordered_descendly</code></td>
<td>
<p>in case that the elements in commun are numeric, this option can be enabled by giving a value of TRUE or FALSE see examples</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
datf &lt;- data.frame("col1"=c("oui", "oui", "oui", "oui", "oui", "oui", 
                     "non", "non", "non", "non", "ee", "ee", "ee"), "col2"=c(1:6, 2:5, 1:3))

print(intersect_mod(datf=datf, inter_col=2, mod_col=1, n_min=2))

   col1 col2
2   oui    2
3   oui    3
7   non    2
8   non    3
12   ee    2
13   ee    3

print(intersect_mod(datf=datf, inter_col=2, mod_col=1, n_min=3))

   col1 col2
2   oui    2
3   oui    3
4   oui    4
5   oui    5
7   non    2
8   non    3
9   non    4
10  non    5

print(intersect_mod(datf=datf, inter_col=2, mod_col=1, n_min=5))

  col1 col2
1  oui    1
2  oui    2
3  oui    3
4  oui    4
5  oui    5
6  oui    6

datf &lt;- data.frame("col1"=c("non", "non", "oui", "oui", "oui", "oui", 
                      "non", "non", "non", "non", "ee", "ee", "ee"), "col2"=c(1:6, 2:5, 1:3))

print(intersect_mod(datf=datf, inter_col=2, mod_col=1, n_min=3))

   col1 col2
8   non    3
9   non    4
10  non    5
3   oui    3
4   oui    4
5   oui    5

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: nestr_datf1</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>nestr_datf1</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>nestr_datf1</h2>

<h3>Description</h3>

<p>Allow to write a value (1a) to a dataframe (1b) to its cells that have the same coordinates (row and column) than the cells whose value is equal to a another special value (2a), from another another dataframe (2b). The value (1a) depends of the cell  value coordinates of the third dataframe (3b). If a cell coordinates (1c) of the first dataframe (1b) does not correspond to the coordinates of a good returning cell value (2a) from the dataframe (2b), so this cell (1c) can have its value changed to the same cell coordinates value (3a) of a third dataframe (4b), if (4b) is not set to NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nestr_datf1(
  inptf_datf,
  inptt_pos_datf,
  nestr_datf,
  yes_val = TRUE,
  inptt_neg_datf = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inptf_datf">inptf_datf</code></td>
<td>
<p>is the input dataframe (1b)</p>
</td></tr>
<tr><td><code id="inptt_pos_datf">inptt_pos_datf</code></td>
<td>
<p>is the dataframe (2b) that corresponds to the (1a) values</p>
</td></tr>
<tr><td><code id="nestr_datf">nestr_datf</code></td>
<td>
<p>is the dataframe (2b) that has the special value (2a)</p>
</td></tr>
<tr><td><code id="yes_val">yes_val</code></td>
<td>
<p>is the special value (2a)</p>
</td></tr>
<tr><td><code id="inptt_neg_datf">inptt_neg_datf</code></td>
<td>
<p>is the dataframe (4b) that has the (3a) values, defaults to NA</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
print(nestr_datf1(inptf_datf=data.frame(c(1, 2, 1), c(1, 5, 7)), 
inptt_pos_datf=data.frame(c(4, 4, 3), c(2, 1, 2)), 
inptt_neg_datf=data.frame(c(44, 44, 33), c(12, 12, 12)), 
nestr_datf=data.frame(c(TRUE, FALSE, TRUE), c(FALSE, FALSE, TRUE)), yes_val=TRUE)) 

#  c.1..2..1. c.1..5..7.
#1          4         12
#2         44         12
#3          3          2

print(nestr_datf1(inptf_datf=data.frame(c(1, 2, 1), c(1, 5, 7)), 
inptt_pos_datf=data.frame(c(4, 4, 3), c(2, 1, 2)), 
inptt_neg_datf=NA, 
nestr_datf=data.frame(c(TRUE, FALSE, TRUE), c(FALSE, FALSE, TRUE)), yes_val=TRUE))

#   c.1..2..1. c.1..5..7.
#1          4          1
#2          2          5
#3          3          2

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: nestr_datf2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>nestr_datf2</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>nestr_datf2</h2>

<h3>Description</h3>

<p>Allow to write a special value (1a) in the cells of a dataframe (1b) that correspond (row and column) to whose of another dataframe (2b) that return another special value (2a). The cells whose coordinates do not match the coordinates of the dataframe (2b), another special value can be written (3a) if not set to NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nestr_datf2(inptf_datf, rtn_pos, rtn_neg = NA, nestr_datf, yes_val = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inptf_datf">inptf_datf</code></td>
<td>
<p>is the input dataframe (1b)</p>
</td></tr>
<tr><td><code id="rtn_pos">rtn_pos</code></td>
<td>
<p>is the special value (1a)</p>
</td></tr>
<tr><td><code id="rtn_neg">rtn_neg</code></td>
<td>
<p>is the special value (3a)</p>
</td></tr>
<tr><td><code id="nestr_datf">nestr_datf</code></td>
<td>
<p>is the dataframe (2b)</p>
</td></tr>
<tr><td><code id="yes_val">yes_val</code></td>
<td>
<p>is the special value (2a)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
print(nestr_datf2(inptf_datf=data.frame(c(1, 2, 1), c(1, 5, 7)), rtn_pos="yes", 
rtn_neg="no", nestr_datf=data.frame(c(TRUE, FALSE, TRUE), c(FALSE, FALSE, TRUE)), yes_val=TRUE)) 

#  c.1..2..1. c.1..5..7.
#1        yes         no
#2         no         no
#3        yes        yes

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: paste_datf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>paste_datf</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>paste_datf</h2>

<h3>Description</h3>

<p>Return a vector composed of pasted elements from the input dataframe at the same index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paste_datf(inpt_datf, sep = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inpt_datf">inpt_datf</code></td>
<td>
<p>is the input dataframe</p>
</td></tr>
<tr><td><code id="sep">sep</code></td>
<td>
<p>is the separator between pasted elements, defaults to &quot;&quot;</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
print(paste_datf(inpt_datf=data.frame(c(1, 2, 1), c(33, 22, 55))))

#[1] "133" "222" "155"

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: see_datf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>see_datf</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>see_datf</h2>

<h3>Description</h3>

<p>Allow to return a dataframe with special value cells (ex: TRUE) where the condition entered are respected and another special value cell (ex: FALSE) where these are not
</p>


<h3>Usage</h3>

<pre><code class='language-R'>see_datf(
  datf,
  condition_l,
  val_l,
  conjunction_l = c(),
  rt_val = TRUE,
  f_val = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datf">datf</code></td>
<td>
<p>is the input dataframe</p>
</td></tr>
<tr><td><code id="condition_l">condition_l</code></td>
<td>
<p>is the vector of the possible conditions (&quot;==&quot;, &quot;&gt;&quot;, &quot;&lt;&quot;, &quot;!=&quot;, &quot;%%&quot;, &quot;reg&quot;, &quot;not_reg&quot;, &quot;sup_nchar&quot;, &quot;inf_nchar&quot;, &quot;nchar&quot;) (equal to some elements in a vector, greater than, lower than, not equal to, is divisible by, the regex condition returns TRUE, the regex condition returns FALSE, the length of the elements is strictly superior to X, the length of the element is strictly inferior to X, the length of the element is equal to one element in a vector), you can put the same condition n times.</p>
</td></tr>
<tr><td><code id="val_l">val_l</code></td>
<td>
<p>is the list of vectors containing the values or vector of values related to condition_l (so the vector of values has to be placed in the same order)</p>
</td></tr>
<tr><td><code id="conjunction_l">conjunction_l</code></td>
<td>
<p>contains the and or conjunctions, so if the length of condition_l is equal to 3, there will be 2 conjunctions. If the length of conjunction_l is inferior to the length of condition_l minus 1, conjunction_l will match its goal length value with its last argument as the last arguments. For example, c(&quot;&amp;&quot;, &quot;|&quot;, &quot;&amp;&quot;) with a goal length value of 5 &ndash;&gt; c(&quot;&amp;&quot;, &quot;|&quot;, &quot;&amp;&quot;, &quot;&amp;&quot;, &quot;&amp;&quot;)</p>
</td></tr>
<tr><td><code id="rt_val">rt_val</code></td>
<td>
<p>is a special value cell returned when the conditions are respected</p>
</td></tr>
<tr><td><code id="f_val">f_val</code></td>
<td>
<p>is a special value cell returned when the conditions are not respected</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will return an error if number only comparative conditions are given in addition to having character values in the input dataframe.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
datf1 &lt;- data.frame(c(1, 2, 4), c("a", "a", "zu"))

print(see_datf(datf=datf1, condition_l=c("nchar"), val_l=list(c(1))))

#    X1    X2
#1 TRUE  TRUE
#2 TRUE  TRUE
#3 TRUE FALSE

print(see_datf(datf=datf1, condition_l=c("=="), val_l=list(c("a", 1))))

#    X1    X2
#1  TRUE  TRUE
#2 FALSE  TRUE
#3 FALSE FALSE


print(see_datf(datf=datf1, condition_l=c("nchar"), val_l=list(c(1, 2))))

#    X1   X2
#1 TRUE TRUE
#2 TRUE TRUE
#3 TRUE TRUE

print(see_datf(datf=datf1, condition_l=c("not_reg"), val_l=list("[a-z]")))

#    X1    X2
#1 TRUE FALSE
#2 TRUE FALSE
#3 TRUE FALSE

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: swipr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>swipr</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>swipr</h2>

<h3>Description</h3>

<p>Returns an ordered dataframes according to the elements order given. The input datafram has two columns, one with the ids which can be bonded to multiple elements in the other column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swipr(inpt_datf, how_to = c(), id_w = 2, id_ids = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inpt_datf">inpt_datf</code></td>
<td>
<p>is the input dataframe</p>
</td></tr>
<tr><td><code id="how_to">how_to</code></td>
<td>
<p>is a vector containing the elements in the order wanted</p>
</td></tr>
<tr><td><code id="id_w">id_w</code></td>
<td>
<p>is the column number or the column name of the elements</p>
</td></tr>
<tr><td><code id="id_ids">id_ids</code></td>
<td>
<p>is the column number or the column name of the ids</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
datf &lt;- data.frame("col1"=c("Af", "Al", "Al", "Al", "Arg", "Arg", "Arg", "Arm", "Arm", "Al"),

        "col2"=c("B", "B", "G", "S", "B", "S", "G", "B", "G", "B"))

print(swipr(inpt_datf=datf, how_to=c("G", "S", "B")))

   col1 col2
1    Af    B
2    Al    G
3    Al    S
4    Al    B
5   Arg    G
6   Arg    S
7   Arg    B
8   Arm    G
9   Arm    B
10   Al    B

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: unique_datf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>unique_datf</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>unique_datf</h2>

<h3>Description</h3>

<p>Returns the input dataframe with the unique columns or rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unique_datf(inpt_datf, col = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inpt_datf">inpt_datf</code></td>
<td>
<p>is the input dataframe</p>
</td></tr>
<tr><td><code id="col">col</code></td>
<td>
<p>is a parameter that specifies if the dataframe returned should have unique columns or rows, defaults to F, so the dataframe returned by default has unique rows</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
datf1 &lt;- data.frame(c(1, 2, 1, 3), c("a", "z", "a", "p"))

print(datf1)

  c.1..2..1..3. c..a....z....a....p.. c.1..2..1..3..1
1             1                     a               1
2             2                     z               2
3             1                     a               1
4             3                     p               3

print(unique_datf(inpt_datf=datf1))

#   c.1..2..1..3. c..a....z....a....p..
#1             1                     a
#2             2                     z
#4             3                     p

datf1 &lt;- data.frame(c(1, 2, 1, 3), c("a", "z", "a", "p"), c(1, 2, 1, 3))

print(datf1)

  c.1..2..1..3. c..a....z....a....p..
1             1                     a
2             2                     z
3             1                     a
4             3                     p

print(unique_datf(inpt_datf=datf1, col=TRUE))

#  cur_v cur_v
#1     1     a
#2     2     z
#3     1     a
#4     3     p

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: val_replacer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>val_replacer</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>val_replacer</h2>

<h3>Description</h3>

<p>Allow to replace value from dataframe to another one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>val_replacer(datf, val_replaced, val_replacor = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datf">datf</code></td>
<td>
<p>is the input dataframe</p>
</td></tr>
<tr><td><code id="val_replaced">val_replaced</code></td>
<td>
<p>is a vector of the value(s) to be replaced</p>
</td></tr>
<tr><td><code id="val_replacor">val_replacor</code></td>
<td>
<p>is the value that will replace val_replaced</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
print(val_replacer(datf=data.frame(c(1, "oo4", TRUE, FALSE), c(TRUE, FALSE, TRUE, TRUE)), 
     val_replaced=c(TRUE), val_replacor="NA"))

#  c.1...oo4...T..F. c.T..F..T..T.
#1                 1            NA
#2               oo4         FALSE
#3                NA            NA
#4             FALSE            NA

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: vec_in_datf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>vec_in_datf</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>vec_in_datf</h2>

<h3>Description</h3>

<p>Allow to get if a vector is in a dataframe. Returns the row and column of the vector in the dataframe if the vector is contained in the dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_in_datf(
  inpt_datf,
  inpt_vec = c(),
  coeff = 0,
  stop_untl = 1,
  conventional = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inpt_datf">inpt_datf</code></td>
<td>
<p>is the input dataframe</p>
</td></tr>
<tr><td><code id="inpt_vec">inpt_vec</code></td>
<td>
<p>is the vector that may be in the input dataframe</p>
</td></tr>
<tr><td><code id="coeff">coeff</code></td>
<td>
<p>is the &quot;slope coefficient&quot; of inpt_vec</p>
</td></tr>
<tr><td><code id="stop_untl">stop_untl</code></td>
<td>
<p>is the maximum number of the input vector the function returns, if in the dataframe</p>
</td></tr>
<tr><td><code id="conventional">conventional</code></td>
<td>
<p>is if a positive slope coefficient means that the vector goes upward or downward</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
datf1 &lt;- data.frame(c(1:5), c(5:1), c("a", "z", "z", "z", "a"))

print(datf1)

#  c.1.5. c.5.1. c..a....z....z....z....a..
#1      1      5                          a
#2      2      4                          z
#3      3      3                          z
#4      4      2                          z
#5      5      1                          a

print(vec_in_datf(inpt_datf=datf1, inpt_vec=c(5, 4, "z"), coeff=1))

#NULL

print(vec_in_datf(inpt_datf=datf1, inpt_vec=c(5, 2, "z"), coeff=1))

#[1] 5 1

print(vec_in_datf(inpt_datf=datf1, inpt_vec=c(3, "z"), coeff=1))

#[1] 3 2

print(vec_in_datf(inpt_datf=datf1, inpt_vec=c(4, "z"), coeff=-1))

#[1] 2 2

print(vec_in_datf(inpt_datf=datf1, inpt_vec=c(2, 3, "z"), coeff=-1))

#[1] 2 1

print(vec_in_datf(inpt_datf=datf1, inpt_vec=c(5, 2, "z"), coeff=-1, conventional=TRUE))
 
#[1] 5 1

datf1[4, 2] &lt;- 1

print(vec_in_datf(inpt_datf=datf1, inpt_vec=c(1, "z"), coeff=-1, conventional=TRUE, stop_untl=4))

#[1] 4 2 5 2

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: vlookup_datf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>vlookup_datf</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>vlookup_datf</h2>

<h3>Description</h3>

<p>Alow to perform a vlookup on a dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vlookup_datf(datf, v_id, col_id = 1, included_col_id = "yes")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datf">datf</code></td>
<td>
<p>is the input dataframe</p>
</td></tr>
<tr><td><code id="v_id">v_id</code></td>
<td>
<p>is a vector containing the ids</p>
</td></tr>
<tr><td><code id="col_id">col_id</code></td>
<td>
<p>is the column that contains the ids (default is equal to 1)</p>
</td></tr>
<tr><td><code id="included_col_id">included_col_id</code></td>
<td>
<p>is if the result should return the col_id (default set to yes)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
datf1 &lt;- data.frame(c("az1", "az3", "az4", "az2"), c(1:4), c(4:1))

print(vlookup_datf(datf=datf1, v_id=c("az1", "az2", "az3", "az4")))

#   c..az1....az3....az4....az2.. c.1.4. c.4.1.
#2                            az1      1      4
#4                            az2      4      1
#21                           az3      2      3
#3                            az4      3      2

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: wider_datf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>wider_datf</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>wider_datf</h2>

<h3>Description</h3>

<p>Takes a dataframe as an input and the column to split according to a seprator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wider_datf(inpt_datf, col_to_splt = c(), sep_ = "-")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inpt_datf">inpt_datf</code></td>
<td>
<p>is the input dataframe</p>
</td></tr>
<tr><td><code id="col_to_splt">col_to_splt</code></td>
<td>
<p>is a vector containing the number or the colnames of the columns to split according to a separator</p>
</td></tr>
<tr><td><code id="sep_">sep_</code></td>
<td>
<p>is the separator of the elements to split to new columns in the input dataframe</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
datf1 &lt;- data.frame(c(1:5), c("o-y", "hj-yy", "er-y", "k-ll", "ooo-mm"), c(5:1))

datf2 &lt;- data.frame("col1"=c(1:5), "col2"=c("o-y", "hj-yy", "er-y", "k-ll", "ooo-mm"))
 
print(wider_datf(inpt_datf=datf1, col_to_splt=c(2), sep_="-"))

#       pre_datf X.o.  X.y.  
#o-y    1      "o"   "y"  5
#hj-yy  2      "hj"  "yy" 4
#er-y   3      "er"  "y"  3
#k-ll   4      "k"   "ll" 2
#ooo-mm 5      "ooo" "mm" 1

print(wider_datf(inpt_datf=datf2, col_to_splt=c("col2"), sep_="-"))

#       pre_datf X.o.  X.y.
#o-y    1      "o"   "y" 
#hj-yy  2      "hj"  "yy"
#er-y   3      "er"  "y" 
#k-ll   4      "k"   "ll"
#ooo-mm 5      "ooo" "mm"

</code></pre>

</main>

</div>
</body></html>
